<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Buttons - Wasefire</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../overview/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../overview/terminology.html"><strong aria-hidden="true">1.1.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="../../overview/features.html"><strong aria-hidden="true">1.2.</strong> Features</a></li></ol></li><li class="chapter-item expanded "><a href="../../applet/index.html"><strong aria-hidden="true">2.</strong> Applet user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../applet/setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../applet/create.html"><strong aria-hidden="true">2.2.</strong> Create a new applet</a></li><li class="chapter-item expanded "><a href="../../applet/run.html"><strong aria-hidden="true">2.3.</strong> Run an applet</a></li><li class="chapter-item expanded "><a href="../../applet/api.html"><strong aria-hidden="true">2.4.</strong> API</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/index.html"><strong aria-hidden="true">2.5.</strong> Prelude</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../applet/prelude/led.html"><strong aria-hidden="true">2.5.1.</strong> LEDs</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/button.html" class="active"><strong aria-hidden="true">2.5.2.</strong> Buttons</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/timer.html"><strong aria-hidden="true">2.5.3.</strong> Timers</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/usb.html"><strong aria-hidden="true">2.5.4.</strong> USB</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/store.html"><strong aria-hidden="true">2.5.5.</strong> Storage</a></li></ol></li><li class="chapter-item expanded "><a href="../../applet/examples.html"><strong aria-hidden="true">2.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../../runner/index.html"><strong aria-hidden="true">3.</strong> Runner user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../runner/api.html"><strong aria-hidden="true">3.1.</strong> API</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Developer guide</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Design</div></li></ol></li><li class="chapter-item expanded "><a href="../../faq.html">FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Wasefire</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/google/wasefire/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="buttons"><a class="header" href="#buttons">Buttons</a></h1>
<p>In this section, we will walk through 2 Rust examples:</p>
<ul>
<li>The <code>button</code> example illustrates stateless usage but lets us introduce how to
handle events with callbacks.</li>
<li>The <code>led</code> example illustrates stateful usage and thus how to access state in
callbacks.</li>
</ul>
<h2 id="stateless-usage"><a class="header" href="#stateless-usage">Stateless usage</a></h2>
<p>This example prints to the debug output the new state of a button each time that
button changed state and so for all buttons.</p>
<p>Similarly to LEDs, there is a <code>button::count()</code> function to discover the number
of buttons available on the board:</p>
<pre><code class="language-rust no_run noplayground">    // Make sure there is at least one button.
    let count = button::count();
    assert!(count &gt; 0, &quot;Board has no buttons.&quot;);</code></pre>
<p>We want to listen on events for all available buttons, so we loop over all
button indices (starting at 0):</p>
<pre><code class="language-rust no_run noplayground">    // For each button on the board.
    for index in 0 .. count {</code></pre>
<p>For each button, we define a handler that prints the new button state to the
debug output. The handler takes the new button state as argument. Since
<code>button::State</code> implements <code>Debug</code>, we simply use <code>{state:?}</code> to print the new
state.</p>
<pre><code class="language-rust no_run noplayground">        // We define a button handler printing the new state.
        let handler = move |state| debug!(&quot;Button {index} has been {state:?}.&quot;);</code></pre>
<p>We can now start listening for events. This is done by creating a
<code>button::Listener</code> which will call the provided handler each time the button
changes state. We specify the button we want to listen to by its index and the
handler as a closure.</p>
<pre><code class="language-rust no_run noplayground">        // We start listening for state changes with the handler.
        let listener = button::Listener::new(index, handler);</code></pre>
<p>A listener continues to listen for events until it is dropped. Since we want to
indefinitely listen, we must not drop the listener. A simple way to do that is
to leak it. This is equivalent to calling <code>core::mem::forget()</code>.</p>
<pre><code class="language-rust no_run noplayground">        // We leak the listener to continue listening for events.
        listener.leak();</code></pre>
<p>Finally, we just endlessly wait for callbacks. This step will eventually not be
needed. Waiting for callbacks indefinitely will be the implicit behavior when
<code>main</code> exits, in which case <code>main</code> can be seen as a callback setup procedure.
The <code>scheduling::wait_for_callback()</code> function puts the applet to sleep until a
callback is scheduled and <code>scheduled::wait_indefinitely()</code> is just an infinite
loop around <code>wait_for_callback()</code>.</p>
<pre><code class="language-rust no_run noplayground">    // We indefinitely wait for callbacks.
    scheduling::wait_indefinitely();</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

fn main() {
    // Make sure there is at least one button.
    let count = button::count();
    assert!(count &gt; 0, &quot;Board has no buttons.&quot;);

    // For each button on the board.
    for index in 0 .. count {
        // We define a button handler printing the new state.
        let handler = move |state| debug!(&quot;Button {index} has been {state:?}.&quot;);

        // We start listening for state changes with the handler.
        let listener = button::Listener::new(index, handler);

        // We leak the listener to continue listening for events.
        listener.leak();
    }

    // We indefinitely wait for callbacks.
    scheduling::wait_indefinitely();
}</code></pre></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>The <code>host</code> runner currently has 1 button and is controlled by typing <code>button</code> on
a line on <code>stdin</code>. Eventually, the number of buttons will be configurable and
how they are controlled will be improved (for example through some graphical
interface).</p>
<h2 id="stateful-usage"><a class="header" href="#stateful-usage">Stateful usage</a></h2>
<p>This example combines all the LEDs and buttons available on the board by
maintaining a dynamic mapping between them. Initially, all buttons map to the
first LED. Each time a button is pressed or released, the LED it is mapped to is
toggled. And when a button is released, it maps to the next LED (or the first
one if it was mapping to the last one).</p>
<p>In particular:</p>
<ul>
<li>A single button can toggle all LEDs.</li>
<li>Multiple buttons can toggle the same LED.</li>
<li>A button may stay pressed while another button is pressed.</li>
<li>All buttons eventually toggle all LEDs.</li>
</ul>
<p>We skip over the setup which doesn't illustrate anything new:</p>
<pre><code class="language-rust no_run noplayground">    // Make sure there is at least one button.
    let num_buttons = button::count();
    assert!(num_buttons &gt; 0, &quot;Board has no buttons.&quot;);

    // Make sure there is at least one LED.
    let num_leds = led::count();
    assert!(num_leds &gt; 0, &quot;Board has no LEDs.&quot;);

    // For each button on the board.
    for button_index in 0 .. num_buttons {</code></pre>
<p>Because buttons dynamically map to a LED, we need a state to store this
information. We create this state on the heap because we will eventually leak
the listener and exit the <code>main</code> function to indefinitely listen for button
events. This state simply contains the index of the LED to which this buttons
maps to. We have to use <code>Cell</code> because the handler is called as <code>&amp;self</code> (and
thus closures must be <code>Fn</code> not <code>FnMut</code>)<sup class="footnote-reference"><a href="#cell">1</a></sup>.</p>
<pre><code class="language-rust no_run noplayground">        // We create the state containing the LED to which this button maps to.
        let led_pointer = Box::new(Cell::new(0));</code></pre>
<p>When defining the button handler, we must move (and thus transfer ownership of)
the state we just created to the handler, such that the handler can read and
write the state when called.</p>
<pre><code class="language-rust no_run noplayground">        // We define the button handler and move the state to there.
        let handler = move |button_state| {</code></pre>
<p>When the handler is called, we first toggle the associated LED:</p>
<pre><code class="language-rust no_run noplayground">            // We toggle the LED.
            let led_index = led_pointer.get();
            led::set(led_index, !led::get(led_index));</code></pre>
<p>And then if the button is released, we update the dynamic mapping to point to
the next LED (wrapping if needed):</p>
<pre><code class="language-rust no_run noplayground">            // If the button is released, we point it to the next LED.
            if matches!(button_state, button::Released) {
                led_pointer.set((led_index + 1) % num_leds);
            }</code></pre>
<p>Finally, we create a button listener with the defined handler. And we leak it to
continue listening after it going out of scope and in particular after <code>main</code>
returns.</p>
<pre><code class="language-rust no_run noplayground">        // We indefinitely listen by creating and leaking a listener.
        button::Listener::new(button_index, handler).leak();</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use alloc::boxed::Box;
use core::cell::Cell;

fn main() {
    // Make sure there is at least one button.
    let num_buttons = button::count();
    assert!(num_buttons &gt; 0, &quot;Board has no buttons.&quot;);

    // Make sure there is at least one LED.
    let num_leds = led::count();
    assert!(num_leds &gt; 0, &quot;Board has no LEDs.&quot;);

    // For each button on the board.
    for button_index in 0 .. num_buttons {
        // We create the state containing the LED to which this button maps to.
        let led_pointer = Box::new(Cell::new(0));

        // We define the button handler and move the state to there.
        let handler = move |button_state| {
            // We toggle the LED.
            let led_index = led_pointer.get();
            led::set(led_index, !led::get(led_index));

            // If the button is released, we point it to the next LED.
            if matches!(button_state, button::Released) {
                led_pointer.set((led_index + 1) % num_leds);
            }
        };

        // We indefinitely listen by creating and leaking a listener.
        button::Listener::new(button_index, handler).leak();
    }

    // We indefinitely wait for callbacks.
    scheduling::wait_indefinitely();
}</code></pre></pre>
<div class="footnote-definition" id="cell"><sup class="footnote-definition-label">1</sup>
<p>This is because the handler could wait for callbacks itself (which the
prelude has no way to know, or is there?) and thus the handler may be
reentered. This would essentially copy a mutable reference which is unsound.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../applet/prelude/led.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../applet/prelude/timer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../applet/prelude/led.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../applet/prelude/timer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
