<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Timers - Wasefire</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../overview/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../overview/terminology.html"><strong aria-hidden="true">1.1.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="../../overview/features.html"><strong aria-hidden="true">1.2.</strong> Features</a></li></ol></li><li class="chapter-item expanded "><a href="../../applet/index.html"><strong aria-hidden="true">2.</strong> Applet user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../applet/setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../applet/create.html"><strong aria-hidden="true">2.2.</strong> Create a new applet</a></li><li class="chapter-item expanded "><a href="../../applet/run.html"><strong aria-hidden="true">2.3.</strong> Run an applet</a></li><li class="chapter-item expanded "><a href="../../applet/api.html"><strong aria-hidden="true">2.4.</strong> API</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/index.html"><strong aria-hidden="true">2.5.</strong> Prelude</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../applet/prelude/led.html"><strong aria-hidden="true">2.5.1.</strong> LEDs</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/button.html"><strong aria-hidden="true">2.5.2.</strong> Buttons</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/timer.html" class="active"><strong aria-hidden="true">2.5.3.</strong> Timers</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/usb.html"><strong aria-hidden="true">2.5.4.</strong> USB</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/store.html"><strong aria-hidden="true">2.5.5.</strong> Storage</a></li></ol></li><li class="chapter-item expanded "><a href="../../applet/examples.html"><strong aria-hidden="true">2.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../../runner/index.html"><strong aria-hidden="true">3.</strong> Runner user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../runner/api.html"><strong aria-hidden="true">3.1.</strong> API</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Developer guide</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Design</div></li></ol></li><li class="chapter-item expanded "><a href="../../faq.html">FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Wasefire</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/google/wasefire/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="timers"><a class="header" href="#timers">Timers</a></h1>
<p>In this section, we will walk through the <code>button_abort</code> example in Rust. It
uses the first button and the first LED of the board. On a short press, the LED
will start blinking. On a long press, the LED will stop blinking. While the
button is pressed, the LED indicates whether the press is short or long:</p>
<ul>
<li>The LED is on while the press is short.</li>
<li>The LED turns off once the press is long.</li>
</ul>
<p>This applet will need a shared state to know whether the LED must be blinking or
not. We cannot simply use a boolean because the state will be shared. We cannot
use <code>Cell&lt;bool&gt;</code> neither because the state must be in the heap<sup class="footnote-reference"><a href="#heap">1</a></sup>. So we use
<code>Rc&lt;Cell&lt;bool&gt;&gt;</code> which is a common pattern when using callbacks:</p>
<pre><code class="language-rust no_run noplayground">    // We define a shared state to decide whether we must blink.
    let blinking = Rc::new(Cell::new(false));</code></pre>
<p>We can now allocate a timer for the blinking behavior using <code>clock::Timer::new</code>.
This function takes the handler that will be called each time the timer fires.
The handler simply toggles the LED if we must be blinking. Note how we must move
a clone of the state to the callback. This is also a common pattern when using
callbacks, because callbacks must be <code>'static</code><sup class="footnote-reference"><a href="#heap">1</a></sup>:</p>
<pre><code class="language-rust no_run noplayground">    // Allocate a timer for blinking the LED.
    let blink = clock::Timer::new({
        // Move a clone of the state to the callback.
        let blinking = blinking.clone();
        move || {
            // Toggle the LED if blinking.
            if blinking.get() {
                led::set(0, !led::get(0));
            }
        }
    });</code></pre>
<p>The rest of the code is done in an infinite loop:</p>
<pre><code class="language-rust no_run noplayground">    loop {</code></pre>
<p>At each iteration, we start by setting up a <code>button::Listener</code> to record whether
the button was pressed and then released. The logic is similar to the callback
setup for the timer. The small difference is that we won't need to call any
function on the listener so we prefix its variable name <code>_button</code> with an
underscore. We cannot simply omit the variable name because we don't want to
drop it until the end of the loop iteration, otherwise we would stop listening
to button events.</p>
<pre><code class="language-rust no_run noplayground">        // Setup button listeners.
        let pressed = Rc::new(Cell::new(false));
        let released = Rc::new(Cell::new(false));
        let _button = button::Listener::new(0, {
            let pressed = pressed.clone();
            let released = released.clone();
            move |state| match state {
                button::Pressed =&gt; pressed.set(true),
                button::Released if pressed.get() =&gt; released.set(true),
                button::Released =&gt; (),
            }
        });</code></pre>
<p>We then wait until the button is pressed using <code>scheduling::wait_until()</code>. This
function takes a condition as argument and only executes callbacks until the
condition is satisfied.</p>
<pre><code class="language-rust no_run noplayground">        // Wait for the button to be pressed.
        scheduling::wait_until(|| pressed.get());</code></pre>
<p>According to the specification of this example applet, when the button is
pressed we must turn on the LED (and stop blinking if we were blinking) to
signal a possible short press. Note that callbacks can only executed when a
scheduling function is called, so we are essentially in a critical section. As
such, the order in which we do those 3 lines doesn't matter. However, a callback
might be scheduled before we stop the <code>blink</code> timer. It will execute next time
we call a scheduling function. This is ok because when that will happen, the
<code>blinking</code> state will be <code>false</code> and the <code>blink</code> handler will do nothing.</p>
<pre><code class="language-rust no_run noplayground">        // Turn the LED on.
        blink.stop();
        blinking.set(false);
        led::set(0, led::On);</code></pre>
<p>To detect a long press, we need to start a timer. There is nothing new here
except the <code>Timer::start()</code> function which takes the timer mode (one-shot or
periodic) and its duration.</p>
<pre><code class="language-rust no_run noplayground">        // Start the timeout to decide between short and long press.
        let timed_out = Rc::new(Cell::new(false));
        let timer = clock::Timer::new({
            let timed_out = timed_out.clone();
            move || timed_out.set(true)
        });
        timer.start(clock::Oneshot, Duration::from_secs(1));</code></pre>
<p>We now wait for the first event between the button being released and the
timeout firing. This is simply done by using a condition which is a disjunction
of the events of interest. This is a common pattern when implementing behavior
with a timeout.</p>
<pre><code class="language-rust no_run noplayground">        // Wait for the button to be released or the timeout to fire.
        scheduling::wait_until(|| released.get() || timed_out.get());</code></pre>
<p>To signal that the timeout was reached or the button was released, we turn off
the LED.</p>
<pre><code class="language-rust no_run noplayground">        // Turn the LED off.
        led::set(0, led::Off);</code></pre>
<p>Finally, if the press was short (i.e. the button was released before the
timeout), we start blinking. This demonstrates the use of periodic timers.</p>
<pre><code class="language-rust no_run noplayground">        // Start blinking if short press.
        if !timed_out.get() {
            blinking.set(true);
            blink.start(clock::Periodic, Duration::from_millis(200));
        }</code></pre>
<p>There are a few things to note:</p>
<ul>
<li>The code is implicit in Rust, but the button handler and the timer handler
within the loop iteration are dropped before the next iteration. This means
that their callbacks are unregistered. This could be done explicitly by
calling <code>core::mem::drop()</code> on their variable if needed.</li>
<li>It is not needed to start and stop the <code>blink</code> timer within the loop as long
as it is started before entering the loop. This is just an optimization to
avoid calling the handler when we know that the <code>blinking</code> shared state is
<code>false</code>, because the handler would do nothing in that case.</li>
</ul>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use alloc::rc::Rc;
use core::cell::Cell;
use core::time::Duration;

fn main() {
    assert!(button::count() &gt; 0, &quot;Board has no buttons.&quot;);
    assert!(led::count() &gt; 0, &quot;Board has no LEDs.&quot;);

    // We define a shared state to decide whether we must blink.
    let blinking = Rc::new(Cell::new(false));

    // Allocate a timer for blinking the LED.
    let blink = clock::Timer::new({
        // Move a clone of the state to the callback.
        let blinking = blinking.clone();
        move || {
            // Toggle the LED if blinking.
            if blinking.get() {
                led::set(0, !led::get(0));
            }
        }
    });

    loop {
        // Setup button listeners.
        let pressed = Rc::new(Cell::new(false));
        let released = Rc::new(Cell::new(false));
        let _button = button::Listener::new(0, {
            let pressed = pressed.clone();
            let released = released.clone();
            move |state| match state {
                button::Pressed =&gt; pressed.set(true),
                button::Released if pressed.get() =&gt; released.set(true),
                button::Released =&gt; (),
            }
        });

        // Wait for the button to be pressed.
        scheduling::wait_until(|| pressed.get());

        // Turn the LED on.
        blink.stop();
        blinking.set(false);
        led::set(0, led::On);

        // Start the timeout to decide between short and long press.
        let timed_out = Rc::new(Cell::new(false));
        let timer = clock::Timer::new({
            let timed_out = timed_out.clone();
            move || timed_out.set(true)
        });
        timer.start(clock::Oneshot, Duration::from_secs(1));

        // Wait for the button to be released or the timeout to fire.
        scheduling::wait_until(|| released.get() || timed_out.get());

        // Turn the LED off.
        led::set(0, led::Off);

        // Start blinking if short press.
        if !timed_out.get() {
            blinking.set(true);
            blink.start(clock::Periodic, Duration::from_millis(200));
        }
    }
}</code></pre></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>As for the LEDs and buttons examples, to test the applet on the <code>host</code> runner,
you'll need to use:</p>
<pre><code class="language-shell">cargo xtask applet rust button_abort runner host --log=info
</code></pre>
<p>However, in addition to <code>button</code> which does a press and release sequence, you
can use <code>press</code> and <code>release</code> to independently press and release the button. In
particular, <code>button</code> may be used to start blinking and <code>press</code> may be used to
stop blinking. There's no need to explicitly release because the applet supports
missing callbacks for robustness.</p>
<div class="footnote-definition" id="heap"><sup class="footnote-definition-label">1</sup>
<p>If the state were on the stack and a callback were pointing to that
state, it would become a safety requirement to unregister the callback
before popping the state from the stack. However, it is safe to leak a
callback with <code>core::mem::forget()</code> and thus not drop it. So we enforce
callbacks to be <code>'static</code> and thus not depend on references to the stack.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../applet/prelude/button.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../applet/prelude/usb.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../applet/prelude/button.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../applet/prelude/usb.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
