<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>USB - Wasefire</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../overview/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../overview/terminology.html"><strong aria-hidden="true">1.1.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="../../overview/features.html"><strong aria-hidden="true">1.2.</strong> Features</a></li></ol></li><li class="chapter-item expanded "><a href="../../applet/index.html"><strong aria-hidden="true">2.</strong> Applet user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../applet/setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../applet/create.html"><strong aria-hidden="true">2.2.</strong> Create a new applet</a></li><li class="chapter-item expanded "><a href="../../applet/run.html"><strong aria-hidden="true">2.3.</strong> Run an applet</a></li><li class="chapter-item expanded "><a href="../../applet/api.html"><strong aria-hidden="true">2.4.</strong> API</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/index.html"><strong aria-hidden="true">2.5.</strong> Prelude</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../applet/prelude/led.html"><strong aria-hidden="true">2.5.1.</strong> LEDs</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/button.html"><strong aria-hidden="true">2.5.2.</strong> Buttons</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/timer.html"><strong aria-hidden="true">2.5.3.</strong> Timers</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/usb.html" class="active"><strong aria-hidden="true">2.5.4.</strong> USB</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/store.html"><strong aria-hidden="true">2.5.5.</strong> Storage</a></li></ol></li><li class="chapter-item expanded "><a href="../../applet/examples.html"><strong aria-hidden="true">2.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../../runner/index.html"><strong aria-hidden="true">3.</strong> Runner user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../runner/api.html"><strong aria-hidden="true">3.1.</strong> API</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Developer guide</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Design</div></li></ol></li><li class="chapter-item expanded "><a href="../../faq.html">FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Wasefire</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/google/wasefire/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="usb"><a class="header" href="#usb">USB</a></h1>
<p>For now only USB serial is supported. Eventually, the idea would be for applets
to describe the USB interfaces they need in some init function. The scheduler
would then create the USB device based on those information. And only then start
the applets with capabilities to the interfaces they asked for.</p>
<p>In this section, we will illustrate USB serial usage by walking through the
<code>memory_game</code> example. The game is essentially an infinite loop of memory
questions. The player has 3 seconds to memorize a random base32 string (the
length is the current level in the game and thus represents the difficulty). The
player than has 7 seconds to type it back. On success they go to the next level,
otherwise to the previous level.</p>
<p>The applet has only 2 states across loop iterations:</p>
<ul>
<li>The level of the game (and thus the length of the string to remember) starting
at 3.</li>
<li>The next prompt to show to the player while they get ready for the next
question.</li>
</ul>
<pre><code class="language-rust no_run noplayground">    let mut level = 3; // length of the string to remember
    let mut prompt = &quot;Press ENTER when you are ready.&quot;;</code></pre>
<p>Everything else is in the infinite loop:</p>
<pre><code class="language-rust no_run noplayground">    loop {</code></pre>
<p>First thing we do is print the prompt and wait for the player to press Enter. We
use ANSI escape codes to overwrite whatever was there before. As an invariant
throughout the game, we always use a single line of the terminal. This is
particularly important to overwrite the question since the player has to guess
it. We write to the USB serial using <code>usb::serial::write_all()</code>.</p>
<pre><code class="language-rust no_run noplayground">        usb::serial::write_all(format!(&quot;\r\x1b[K{prompt}&quot;).as_bytes()).unwrap();</code></pre>
<p>We then wait until the player press Enter. We can read a single byte from the
USB serial using <code>usb::serial::read_byte()</code>. The terminal sends <code>0x0d</code> when
Enter is pressed.</p>
<pre><code class="language-rust no_run noplayground">        // Make sure the player is ready.
        while usb::serial::read_byte().unwrap() != 0x0d {}</code></pre>
<p>To generate the next question, we use <code>rng::fill_bytes()</code> which fills a buffer
with random bytes. We provide a buffer with the length of the current level. For
the string to be printable we truncate the entropy of each byte from 8 to 5 bits
and convert it to a <code>base32</code> symbol.</p>
<pre><code class="language-rust no_run noplayground">        // Generate a question for this level.
        let mut question = vec![0; level];
        rng::fill_bytes(&amp;mut question).unwrap();
        for byte in &amp;mut question {
            const BASE32: [u8; 32] = *b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;;
            *byte = BASE32[(*byte &amp; 0x1f) as usize];
        }
        let mut question = String::from_utf8(question).unwrap();</code></pre>
<p>We can now show the question to the player. We do so using a <code>process</code> helper
function that we will also use for the answer. We instantiate this function such
that the player has 3 seconds to memorize the question and may hit Enter at any
time to start answering.</p>
<pre><code class="language-rust no_run noplayground">        // Display the question.
        process(3, &quot;Memorize this&quot;, &amp;mut question, |_, x| x == 0x0d);</code></pre>
<p>After 3 seconds have elapsed or if the player hit Enter, we read the answer from
the player. We give them 7 seconds to type the answer. We also convert
lower-case letters to upper-case for convenience (it's easier to read upper-case
but easier to type lower-case). We also support backspace which the terminal
sends as <code>0x7f</code>. And same as for the question, we let the player exit early with
Enter to avoid waiting until the timeout.</p>
<pre><code class="language-rust no_run noplayground">        // Read the answer.
        let mut answer = String::new();
        process(7, &quot;Type what you remember&quot;, &amp;mut answer, |answer, byte| {
            match byte {
                b'A' ..= b'Z' | b'2' ..= b'7' =&gt; answer.push(byte as char),
                b'a' ..= b'z' =&gt; answer.push(byte.to_ascii_uppercase() as char),
                0x7f =&gt; drop(answer.pop()),
                0x0d =&gt; return true,
                _ =&gt; (),
            }
            false
        });</code></pre>
<p>Once we have the answer, we check if it matches the question. If it does, we
promote the player to the next level. If it doesn't, we demote the player to the
previous level. However, if there are no previous level because the player is at
level 1, then we let them retry the level to show our support. We use ANSI
escape codes to highlight the result.</p>
<pre><code class="language-rust no_run noplayground">        // Check the answer.
        if answer == question {
            level += 1;
            prompt = &quot;\x1b[1;32mPromotion!\x1b[m Press ENTER for next level.&quot;;
        } else if level &gt; 1 {
            level -= 1;
            prompt = &quot;\x1b[1;31mDemotion...\x1b[m Press ENTER for previous level.&quot;;
        } else {
            prompt = &quot;\x1b[1;41mRetry?\x1b[m Press ENTER to retry.&quot;;
        }</code></pre>
<p>Now that we're done with the main loop, let's look at the <code>process</code> helper. It
takes 4 arguments:</p>
<ul>
<li><code>max_secs: usize</code>: the maximum display time in seconds.</li>
<li><code>prompt: &amp;str</code>: the message shown at the beginning of the line.</li>
<li><code>data: &amp;mut String</code>: the data shown after the prompt, which may be updated
(see below).</li>
<li><code>update: impl Fn(&amp;mut String, u8) -&gt; bool</code>: the closure called on each input
byte possibly updating the data and returning whether processing should end
immediately without waiting for the maximum display time.</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn process(
    max_secs: usize, prompt: &amp;str, data: &amp;mut String, update: impl Fn(&amp;mut String, u8) -&gt; bool,
) {</code></pre>
<p>The helper counts the number of elapsed seconds in shared variable <code>secs</code> and
updates it using a periodic timer every second.</p>
<pre><code class="language-rust no_run noplayground">    let secs = Rc::new(Cell::new(0));
    let timer = clock::Timer::new({
        let time = secs.clone();
        move || time.set(time.get() + 1)
    });
    timer.start(clock::Periodic, Duration::from_secs(1));</code></pre>
<p>The helper loops as long as the update function didn't say to stop (tracked by
the <code>done</code> variable) and there is still time available.</p>
<pre><code class="language-rust no_run noplayground">    let mut done = false;
    while !done &amp;&amp; secs.get() &lt; max_secs {</code></pre>
<p>We update the line in the terminal with the prompt, time left, and current data.
We use ANSI escape codes to highlight the data and help readability.</p>
<pre><code class="language-rust no_run noplayground">        let secs = max_secs - secs.get();
        let message = format!(&quot;\r\x1b[K{prompt} ({secs} seconds remaining): \x1b[1m{data}\x1b[m&quot;);
        usb::serial::write_all(message.as_bytes()).unwrap();</code></pre>
<p>To be able to update the time left in the terminal we must read from the USB
serial asynchronously using <code>usb::serial::Reader</code>. We create a reader by
providing a mutable buffer to which the reader will write the received bytes.</p>
<pre><code class="language-rust no_run noplayground">        let mut buffer = [0; 8];
        let reader = usb::serial::Reader::new(&amp;mut buffer);</code></pre>
<p>We then sleep until a callback is executed using
<code>scheduling::wait_for_callback()</code>. This callback may either be the timer firing
the next second or the reader getting input from the USB serial.</p>
<pre><code class="language-rust no_run noplayground">        scheduling::wait_for_callback();</code></pre>
<p>We call <code>Reader::result()</code> to know how many bytes were read from USB serial and
written to the buffer (or if an error occurred). We then simply iterate over the
received bytes and update the data and early exit status according to the
provided closure. Same as with timers, when a reader is dropped, its callback is
canceled.</p>
<pre><code class="language-rust no_run noplayground">        let len = reader.result().unwrap();
        for &amp;byte in &amp;buffer[.. len] {
            done |= update(data, byte);
        }</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use alloc::rc::Rc;
use alloc::string::String;
use alloc::{format, vec};
use core::cell::Cell;
use core::time::Duration;

fn main() {
    let mut level = 3; // length of the string to remember
    let mut prompt = &quot;Press ENTER when you are ready.&quot;;
    loop {
        usb::serial::write_all(format!(&quot;\r\x1b[K{prompt}&quot;).as_bytes()).unwrap();

        // Make sure the player is ready.
        while usb::serial::read_byte().unwrap() != 0x0d {}

        // Generate a question for this level.
        let mut question = vec![0; level];
        rng::fill_bytes(&amp;mut question).unwrap();
        for byte in &amp;mut question {
            const BASE32: [u8; 32] = *b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;;
            *byte = BASE32[(*byte &amp; 0x1f) as usize];
        }
        let mut question = String::from_utf8(question).unwrap();

        // Display the question.
        process(3, &quot;Memorize this&quot;, &amp;mut question, |_, x| x == 0x0d);

        // Read the answer.
        let mut answer = String::new();
        process(7, &quot;Type what you remember&quot;, &amp;mut answer, |answer, byte| {
            match byte {
                b'A' ..= b'Z' | b'2' ..= b'7' =&gt; answer.push(byte as char),
                b'a' ..= b'z' =&gt; answer.push(byte.to_ascii_uppercase() as char),
                0x7f =&gt; drop(answer.pop()),
                0x0d =&gt; return true,
                _ =&gt; (),
            }
            false
        });

        // Check the answer.
        if answer == question {
            level += 1;
            prompt = &quot;\x1b[1;32mPromotion!\x1b[m Press ENTER for next level.&quot;;
        } else if level &gt; 1 {
            level -= 1;
            prompt = &quot;\x1b[1;31mDemotion...\x1b[m Press ENTER for previous level.&quot;;
        } else {
            prompt = &quot;\x1b[1;41mRetry?\x1b[m Press ENTER to retry.&quot;;
        }
    }
}

fn process(
    max_secs: usize, prompt: &amp;str, data: &amp;mut String, update: impl Fn(&amp;mut String, u8) -&gt; bool,
) {
    let secs = Rc::new(Cell::new(0));
    let timer = clock::Timer::new({
        let time = secs.clone();
        move || time.set(time.get() + 1)
    });
    timer.start(clock::Periodic, Duration::from_secs(1));
    let mut done = false;
    while !done &amp;&amp; secs.get() &lt; max_secs {
        let secs = max_secs - secs.get();
        let message = format!(&quot;\r\x1b[K{prompt} ({secs} seconds remaining): \x1b[1m{data}\x1b[m&quot;);
        usb::serial::write_all(message.as_bytes()).unwrap();
        let mut buffer = [0; 8];
        let reader = usb::serial::Reader::new(&amp;mut buffer);
        scheduling::wait_for_callback();
        let len = reader.result().unwrap();
        for &amp;byte in &amp;buffer[.. len] {
            done |= update(data, byte);
        }
    }
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../applet/prelude/timer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../applet/prelude/store.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../applet/prelude/timer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../applet/prelude/store.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
